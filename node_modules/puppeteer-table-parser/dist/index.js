// src/types.ts
var RowValidationPolicy = /* @__PURE__ */ ((RowValidationPolicy2) => {
  RowValidationPolicy2["NONE"] = "NONE";
  RowValidationPolicy2["NON_EMPTY"] = "NON_EMPTY";
  RowValidationPolicy2["EXACT_MATCH"] = "EXACT_MATCH";
  return RowValidationPolicy2;
})(RowValidationPolicy || {});

// src/errors.ts
var GeneralError = class extends Error {
};
var NoTablesFoundError = class extends GeneralError {
};
var InvalidSettingsError = class extends GeneralError {
};
var MissingRequiredColumnsError = class extends GeneralError {
};
var InvalidColumnError = class extends GeneralError {
};

// src/helpers.ts
var identity = (value) => value;
var extraColsMapperFactory = (extraCols) => {
  if (extraCols.length === 0) {
    return identity;
  }
  const withPos = extraCols.filter((extraCol) => extraCol.position !== void 0).sort((a, b) => {
    return a.position - b.position;
  });
  const withoutPos = extraCols.filter((extraCol) => extraCol.position === void 0);
  return (row, key = "data") => {
    const newRow = row.slice();
    withPos.forEach((extraCol) => {
      newRow.splice(extraCol.position, 0, String(extraCol[key]));
    });
    return newRow.concat(withoutPos.map((extraCol) => String(extraCol[key])));
  };
};
async function getColumnsInfo(settings, headerRow, extraColsMapper) {
  const allowedColNamesKeys = Object.keys(settings.allowedColNames);
  const missingColNames = { ...settings.allowedColNames };
  const allowedIndexes = (await headerRow.$$eval(
    "td,th",
    (cells, newLine) => {
      return cells.map((cell) => cell.innerText.split(newLine));
    },
    settings.newLine
  )).reduce((acc, text, realIndex) => {
    const colName = String(settings.colFilter(text, realIndex));
    if (settings.allowedColNames.hasOwnProperty(colName)) {
      delete missingColNames[colName];
      const desiredIndex = allowedColNamesKeys.findIndex((key) => key === colName);
      Object.assign(acc, { [realIndex]: desiredIndex });
    }
    return acc;
  }, {});
  const missingRequiredColumns = diffFromSource(
    Object.values(missingColNames),
    settings.optionalColNames
  );
  if (missingRequiredColumns.length > 0) {
    console.warn(`Not matched columns are following entries: `, missingRequiredColumns);
    throw new MissingRequiredColumnsError(
      "Number of filtered columns does not match to required columns count!"
    );
  }
  const excludedKeyIndexes = [];
  const colKeyToIndexWithExcluded = /* @__PURE__ */ new Map();
  const colIndexToKeyWithExcluded = /* @__PURE__ */ new Map();
  extraColsMapper(allowedColNamesKeys, "colName").forEach((key, index) => {
    colKeyToIndexWithExcluded.set(key, index);
    colIndexToKeyWithExcluded.set(index, key);
    const value = settings.allowedColNames[key] || key;
    colKeyToIndexWithExcluded.set(value, index);
    colIndexToKeyWithExcluded.set(index, value);
    if (settings.temporaryColNames.includes(key)) {
      excludedKeyIndexes.push(index);
    }
  });
  const getColumnIndex = (colName) => {
    const index = colKeyToIndexWithExcluded.get(colName);
    if (index === void 0) {
      throw new InvalidColumnError(`Invalid column name! '${colName}'`);
    }
    return index;
  };
  const getColumnName = (colIndex) => {
    const value = colIndexToKeyWithExcluded.get(colIndex);
    if (value === void 0) {
      throw new InvalidColumnError(`Column with index '${colIndex}' does not exist!`);
    }
    return value;
  };
  return {
    indexes: {
      allowed: allowedIndexes,
      excluded: excludedKeyIndexes
    },
    missingColNames: Object.values(missingColNames),
    getColumnIndex,
    getColumnName
  };
}
var diffFromSource = (source, target) => {
  return source.filter((x) => !target.includes(x));
};
var omitUndefined = (source) => {
  const definedPairs = Object.entries(source).filter(([, val]) => val !== void 0);
  return Object.fromEntries(definedPairs);
};

// src/pipelineExecutor.ts
var PipelineExecutor = class {
  constructor(_input) {
    this._input = _input;
  }
  operations = [];
  execute(input) {
    this._input = input || this._input || [];
    function isPromise(p) {
      return p && Object.prototype.toString.call(p) === "[object Promise]";
    }
    if (isPromise(this._input)) {
      return this._input.then((x) => this._execute(x));
    } else {
      return this._execute(this._input);
    }
  }
  _execute(input) {
    const acc = [];
    for (let index = 0; index < input.length; index++) {
      let value = input[index];
      let isValid = true;
      for (const { type, callback } of this.operations) {
        if (type === 0 /* FILTER */) {
          if (!callback(value, index, acc)) {
            isValid = false;
            break;
          }
        } else if (type === 1 /* MAP */) {
          value = callback(value, index, acc);
        } else if (type === 2 /* TRANSFORM */) {
          callback(value, index, acc);
        } else {
          throw new Error("Unknown executor operation!");
        }
      }
      if (isValid) {
        acc.push(value);
      }
    }
    return acc;
  }
  addOperation(operation) {
    this.operations.push(operation);
    return this;
  }
  clear() {
    this.operations.length = 0;
    return this;
  }
  addFilter(callback) {
    return this.addOperation({
      type: 0 /* FILTER */,
      callback
    });
  }
  addMap(callback) {
    return this.addOperation({
      type: 1 /* MAP */,
      callback
    });
  }
  addTransform(callback) {
    return this.addOperation({
      type: 2 /* TRANSFORM */,
      callback
    });
  }
};

// src/aggregations.ts
var takeFirstHandler = (rows) => rows[0];
function groupBy(rows, { cols, handler = takeFirstHandler }, getColumnIndex) {
  const rowsByKey = /* @__PURE__ */ new Map();
  rows.forEach((row) => {
    const key = cols.map((col) => row[getColumnIndex(col)]).join("-");
    if (!rowsByKey.has(key)) {
      rowsByKey.set(key, []);
    }
    rowsByKey.get(key).push(row);
  });
  return Array.from(rowsByKey.values()).map((rows2) => {
    if (rows2.length > 1) {
      return handler(rows2, getColumnIndex);
    }
    return rows2[0];
  });
}

// src/mappers.ts
var asObject = (getColumnName) => (row) => {
  return row.reduce((acc, value, index) => {
    const key = getColumnName(index);
    acc[key] = value;
    return acc;
  }, {});
};
var asCsv = (separator) => (row) => {
  return row.join(separator);
};
var asArray = () => (row) => {
  return row;
};

// src/parseTable.ts
function parseTableFactory(settings) {
  const extraColsMapper = extraColsMapperFactory(settings.extraCols);
  const getHeaderRows = (table) => {
    return settings.headerRowsSelector ? table.$$(settings.headerRowsSelector) : Promise.resolve([]);
  };
  const getBodyRows = (table) => {
    return table.$$(settings.bodyRowsSelector);
  };
  const getOutputHeaderRow = (missingColNames) => {
    const headerRowRaw = Object.values(settings.allowedColNames);
    const sortedHeader = extraColsMapper(headerRowRaw, "colName");
    return sortedHeader.filter((key) => !missingColNames.includes(key));
  };
  const getRowStructureValidator = (allowedIndexes) => {
    if (settings.rowValidationPolicy === "NONE" /* NONE */) {
      return () => true;
    }
    if (settings.rowValidationPolicy === "NON_EMPTY" /* NON_EMPTY */) {
      return (rows) => rows.length > 0;
    }
    if (settings.rowValidationPolicy === "EXACT_MATCH" /* EXACT_MATCH */) {
      return (rows) => rows.length === Object.keys(allowedIndexes).length;
    }
    throw new InvalidSettingsError('Unknown mode for the "rowValidationPolicy"');
  };
  const getRowsData = (allowedIndexes) => (row) => row.$$eval(
    "td",
    (cells, allowedIndexes2) => {
      return cells.map((cell, realIndex) => [cell, realIndex]).filter((_, realIndex) => allowedIndexes2[realIndex] !== void 0).sort((a, b) => {
        const indexA = allowedIndexes2[a[1]];
        const indexB = allowedIndexes2[b[1]];
        return indexA - indexB;
      }).map(([cell]) => cell.innerText);
    },
    allowedIndexes
  );
  return async (table, addHeader) => {
    await table.evaluate((el) => el.scrollIntoView());
    const headerRows = await getHeaderRows(table);
    const bodyRows = await getBodyRows(table);
    if (headerRows.length === 0 && bodyRows.length === 0) {
      return [];
    }
    const headerRow = headerRows.length > 0 ? headerRows.shift() : bodyRows.shift();
    const { indexes, getColumnIndex, getColumnName, missingColNames } = await getColumnsInfo(
      settings,
      headerRow,
      extraColsMapper
    );
    if (settings.reverseTraversal) {
      bodyRows.reverse();
    }
    let parsedRows = await new PipelineExecutor(
      Promise.all(bodyRows.map(getRowsData(indexes.allowed)))
    ).addFilter(getRowStructureValidator(indexes.allowed)).addMap((row) => extraColsMapper(row, "data")).addFilter((row, index, rows) => settings.rowValidator(row, getColumnIndex, index, rows)).addMap((row) => row.map((cell, index) => settings.colParser(cell, index, getColumnIndex))).addTransform((row) => settings.rowTransform(row, getColumnIndex)).execute();
    if (settings.groupBy) {
      parsedRows = groupBy(parsedRows, settings.groupBy, getColumnIndex);
    }
    if (addHeader) {
      const headerRow2 = getOutputHeaderRow(missingColNames);
      parsedRows.unshift(headerRow2);
    }
    const rowOutputMapper = settings.rowValuesAsObject ? asObject(getColumnName) : settings.rowValuesAsArray ? asArray() : asCsv(settings.csvSeparator);
    return new PipelineExecutor(parsedRows).addMap((row) => row.filter((_, index) => !indexes.excluded.includes(index))).addMap(rowOutputMapper).execute();
  };
}

// src/merger.ts
var mergeParserSettings = (to, from, ignoredAllowedColumns = []) => {
  const newConfig = {
    temporaryColNames: to.temporaryColNames.slice(),
    extraCols: to.extraCols.slice(),
    allowedColNames: Object.assign({}, to.allowedColNames)
  };
  newConfig.extraCols.unshift(
    ...from.extraCols.map((extraCol) => {
      extraCol.data = extraCol.data || "";
      return extraCol;
    })
  );
  from.temporaryColNames.filter((tempCol) => !newConfig.temporaryColNames.includes(tempCol)).forEach((tempCol) => newConfig.temporaryColNames.push(tempCol));
  const generalColNames = Object.entries(from.allowedColNames);
  generalColNames.reverse().forEach(([key, val], index) => {
    const realPosition = generalColNames.length - index - 1;
    if (!newConfig.allowedColNames.hasOwnProperty(key) && !ignoredAllowedColumns.includes(key)) {
      const searchEntry = newConfig.extraCols.find((col) => col.colName === key);
      if (searchEntry) {
        searchEntry.position = realPosition;
        return;
      }
      newConfig.extraCols.unshift({
        colName: val,
        data: "",
        position: realPosition
      });
    }
  });
  return newConfig;
};

// src/settings.ts
var defaultSettings = {
  extraCols: [],
  withHeader: true,
  csvSeparator: ";",
  newLine: "\n",
  rowValidationPolicy: "NON_EMPTY" /* NON_EMPTY */,
  groupBy: void 0,
  rowValidator: () => true,
  rowTransform: () => {
  },
  asArray: false,
  rowValuesAsObject: false,
  rowValuesAsArray: false,
  temporaryColNames: [],
  colFilter: (elText) => elText.join(" "),
  colParser: (value) => value.trim(),
  optionalColNames: [],
  reverseTraversal: false,
  headerRowsSelector: "thead tr",
  bodyRowsSelector: "tbody tr"
};
function preprocessSettings(options) {
  const settings = {
    ...defaultSettings,
    ...omitUndefined(options)
  };
  if (!settings.asArray && (settings.rowValuesAsObject || settings.rowValuesAsArray)) {
    settings.asArray = false;
  }
  validateSettings(settings);
  return settings;
}
function validateSettings(settings) {
  const { extraCols, temporaryColNames, allowedColNames } = settings;
  const hasConflict = extraCols.filter((col) => col.position !== void 0).some((a) => extraCols.find((b) => a !== b && a.position === b.position));
  if (hasConflict) {
    throw new InvalidSettingsError("One or more `extraCols` have same position!");
  }
  for (const colName of temporaryColNames) {
    if (!Object.prototype.hasOwnProperty.call(allowedColNames, colName)) {
      throw new InvalidSettingsError(
        `Entry ${colName} in 'temporaryColNames' must exists in 'allowedColNames'!`
      );
    }
  }
  const allowedColNamesValues = Object.values(allowedColNames);
  for (const { colName } of extraCols) {
    if (allowedColNamesValues.includes(colName)) {
      throw new InvalidSettingsError(
        `'${colName}' in 'extraCols' has same name as column in 'allowedColNames'!`
      );
    }
  }
  if (!settings.asArray && settings.rowValuesAsArray) {
    throw new InvalidSettingsError(
      `'rowValuesAsArray' can be set to true only and only if 'asArray' is also true!`
    );
  }
  if (!Array.isArray(settings.optionalColNames)) {
    throw new InvalidSettingsError(`'optionalColNames' must be an "array"`);
  }
  for (const optionalColName of settings.optionalColNames) {
    if (!allowedColNamesValues.includes(optionalColName)) {
      throw new InvalidSettingsError(
        `'${optionalColName}' in 'optionalColNames' does not exists in 'allowedColNames'!`
      );
    }
  }
  if (settings.groupBy) {
    if (!Array.isArray(settings.groupBy.cols)) {
      throw new InvalidSettingsError(`Columns in "groupBy" field must be typeof array`);
    }
    if (settings.groupBy.handler && typeof settings.groupBy.handler !== "function") {
      throw new InvalidSettingsError(`Passed handler to the "groupBy" is not a function`);
    }
  }
  if (settings.rowValuesAsObject && settings.rowValuesAsArray) {
    throw new InvalidSettingsError(
      `Cannot combine "rowValuesAsObject" with "rowValuesAsArray" options!`
    );
  }
}

// src/index.ts
async function retrieveTables(page, selector) {
  await page.waitForSelector(selector);
  const elements = await page.$$(selector);
  const elementsTypes = await Promise.all(
    elements.map((elHandle) => elHandle.evaluate((el) => el.tagName))
  );
  return elements.filter((el, index) => {
    const elType = elementsTypes[index];
    if (elType !== "TABLE") {
      console.warn("Invalid selector! Element is not a table!");
      return false;
    }
    return true;
  });
}
async function tableParser(page, options) {
  const settings = preprocessSettings(options);
  const tables = await retrieveTables(page, settings.selector);
  if (tables.length === 0) {
    throw new NoTablesFoundError("No tables found! Probably wrong table selector!");
  }
  const parseTable = parseTableFactory(settings);
  const tableResults = [];
  let headerFound = false;
  for (const table of tables) {
    const withHeader = settings.withHeader && !settings.rowValuesAsObject && !headerFound;
    const data = await parseTable(table, withHeader);
    if (data.length > 0 && withHeader) {
      headerFound = true;
    }
    tableResults.push(data);
  }
  const filteredDataTables = tableResults.flat().filter(Boolean);
  if (!settings.asArray) {
    return filteredDataTables.join(settings.newLine);
  }
  return filteredDataTables;
}

export { GeneralError, InvalidColumnError, InvalidSettingsError, MissingRequiredColumnsError, NoTablesFoundError, RowValidationPolicy, mergeParserSettings, tableParser };
//# sourceMappingURL=index.js.map