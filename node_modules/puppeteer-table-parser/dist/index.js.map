{"version":3,"sources":["../src/types.ts","../src/errors.ts","../src/helpers.ts","../src/pipelineExecutor.ts","../src/aggregations.ts","../src/mappers.ts","../src/parseTable.ts","../src/merger.ts","../src/settings.ts","../src/index.ts"],"names":["RowValidationPolicy","rows","allowedIndexes","headerRow"],"mappings":"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","sourcesContent":["export interface ExtraCol {\n  colName: string;\n  data: string;\n  position?: number;\n}\n\nexport type GetColumnIndexType = (colName: string) => number;\n\nexport enum RowValidationPolicy {\n  NONE = 'NONE',\n  NON_EMPTY = 'NON_EMPTY',\n  EXACT_MATCH = 'EXACT_MATCH',\n}\n\nexport type GroupByOptions = {\n  cols: string[];\n  handler?: (rows: string[][], getColumnIndex: GetColumnIndexType) => string[];\n};\n\nexport type ParserSettingsOptional = {\n  temporaryColNames: string[];\n  extraCols: ExtraCol[];\n  withHeader: boolean;\n  csvSeparator: string;\n  newLine: string;\n  rowValidationPolicy: RowValidationPolicy;\n  groupBy: GroupByOptions;\n  rowValidator: (\n    row: string[],\n    getColumnIndex: GetColumnIndexType,\n    rowIndex: number,\n    rows: Readonly<string[][]>,\n  ) => boolean;\n  rowTransform: (row: string[], getColumnIndex: GetColumnIndexType) => void;\n  asArray: boolean;\n  rowValuesAsObject: boolean;\n  rowValuesAsArray: boolean;\n  colFilter: (elText: string[], index: number) => string;\n  colParser: (value: string, formattedIndex: number, getColumnIndex: GetColumnIndexType) => string;\n  optionalColNames: string[];\n  reverseTraversal: boolean;\n  headerRowsSelector: string | null;\n  bodyRowsSelector: string;\n};\n\nexport interface ParserSettings extends Partial<ParserSettingsOptional> {\n  selector: string;\n  readonly allowedColNames: Record<string, string>;\n}\n\nexport type FullParserSettings = Required<ParserSettings>;\n\nexport type ExtraColsMapper = (row: string[], key: keyof ExtraCol) => string[];\n\nexport interface MergeParserSettings {\n  allowedColNames: FullParserSettings['allowedColNames'];\n  extraCols: FullParserSettings['extraCols'];\n  temporaryColNames: FullParserSettings['temporaryColNames'];\n}\n\nexport type OmitOrFalsy<T, K extends keyof T> = Omit<T, K> & {\n  [key in K]?: undefined | false;\n};\n","export class GeneralError extends Error {}\n\nexport class NoTablesFoundError extends GeneralError {}\n\nexport class InvalidSettingsError extends GeneralError {}\n\nexport class MissingRequiredColumnsError extends GeneralError {}\n\nexport class InvalidColumnError extends GeneralError {}\n","import type { ExtraCol, ExtraColsMapper } from './types';\nimport type { FullParserSettings } from './types';\nimport { ElementHandle } from 'puppeteer';\nimport { InvalidColumnError, MissingRequiredColumnsError } from './errors';\n\nexport const identity = <T>(value: T): T => value;\n\nexport const extraColsMapperFactory = (extraCols: ExtraCol[]): ExtraColsMapper => {\n  if (extraCols.length === 0) {\n    return identity;\n  }\n\n  const withPos = extraCols\n    .filter((extraCol): extraCol is Required<ExtraCol> => extraCol.position !== undefined)\n    .sort((a, b) => {\n      return a.position! - b.position!;\n    });\n\n  // Append columns without a concrete position\n  const withoutPos = extraCols.filter((extraCol) => extraCol.position === undefined);\n\n  return (row: string[], key: keyof ExtraCol = 'data') => {\n    const newRow = row.slice();\n\n    withPos.forEach((extraCol) => {\n      newRow.splice(extraCol.position, 0, String(extraCol[key]));\n    });\n\n    return newRow.concat(withoutPos.map((extraCol) => String(extraCol[key])));\n  };\n};\n\nexport async function getColumnsInfo(\n  settings: FullParserSettings,\n  headerRow: ElementHandle,\n  extraColsMapper: ReturnType<typeof extraColsMapperFactory>,\n) {\n  const allowedColNamesKeys = Object.keys(settings.allowedColNames);\n\n  // Will be updated during parsing and not found columns will be deleted\n  const missingColNames = { ...settings.allowedColNames };\n\n  // Sorted by finding which was first visited\n  // is index in which we traverse the table, second is final position\n  const allowedIndexes: Record<string, number> = (\n    await headerRow.$$eval(\n      'td,th',\n      (cells: Element[], newLine: string) => {\n        return cells.map((cell) => (cell as HTMLTableCellElement).innerText.split(newLine));\n      },\n      settings.newLine,\n    )\n  ).reduce((acc, text: string[], realIndex: number) => {\n    const colName = String(settings.colFilter(text, realIndex));\n\n    if (settings.allowedColNames.hasOwnProperty(colName)) {\n      delete missingColNames[colName];\n\n      const desiredIndex = allowedColNamesKeys.findIndex((key) => key === colName);\n      Object.assign(acc, { [realIndex]: desiredIndex });\n    }\n\n    return acc;\n  }, {});\n\n  const missingRequiredColumns = diffFromSource(\n    Object.values(missingColNames),\n    settings.optionalColNames,\n  );\n  if (missingRequiredColumns.length > 0) {\n    console.warn(`Not matched columns are following entries: `, missingRequiredColumns);\n    throw new MissingRequiredColumnsError(\n      'Number of filtered columns does not match to required columns count!',\n    );\n  }\n\n  const excludedKeyIndexes: number[] = [];\n  const colKeyToIndexWithExcluded = new Map<string, number>();\n  const colIndexToKeyWithExcluded = new Map<number, string>();\n  extraColsMapper(allowedColNamesKeys, 'colName').forEach((key, index) => {\n    colKeyToIndexWithExcluded.set(key, index);\n    colIndexToKeyWithExcluded.set(index, key);\n\n    const value = settings.allowedColNames[key] || key;\n    colKeyToIndexWithExcluded.set(value, index);\n    colIndexToKeyWithExcluded.set(index, value);\n\n    if (settings.temporaryColNames.includes(key)) {\n      excludedKeyIndexes.push(index);\n    }\n  });\n\n  const getColumnIndex = (colName: string): number => {\n    const index = colKeyToIndexWithExcluded.get(colName);\n    if (index === undefined) {\n      throw new InvalidColumnError(`Invalid column name! '${colName}'`);\n    }\n\n    return index;\n  };\n\n  const getColumnName = (colIndex: number) => {\n    const value = colIndexToKeyWithExcluded.get(colIndex);\n    if (value === undefined) {\n      throw new InvalidColumnError(`Column with index '${colIndex}' does not exist!`);\n    }\n\n    return value;\n  };\n\n  return {\n    indexes: {\n      allowed: allowedIndexes,\n      excluded: excludedKeyIndexes,\n    },\n    missingColNames: Object.values(missingColNames),\n    getColumnIndex,\n    getColumnName,\n  };\n}\n\nexport const diffFromSource = <T>(source: T[], target: T[]): T[] => {\n  return source.filter((x) => !target.includes(x));\n};\n\nexport const omitUndefined = <T extends Record<string, any>>(source: T): Exclude<T, undefined> => {\n  const definedPairs = Object.entries(source).filter(([, val]) => val !== undefined);\n  return Object.fromEntries(definedPairs) as Exclude<T, undefined>;\n};\n","enum OperationType {\n  FILTER,\n  MAP,\n  TRANSFORM,\n}\n\ntype IFilterOperation<T> = {\n  type: OperationType.FILTER;\n  callback: (item: T, index: number, arr: T[]) => boolean;\n};\n\ntype IMapOperation<T> = {\n  type: OperationType.MAP;\n  callback: (item: T, index: number, arr: T[]) => any;\n};\n\ntype ITransformOperation<T> = {\n  type: OperationType.TRANSFORM;\n  callback: (item: T, index: number, arr: T[]) => void;\n};\n\ntype Unwrapped<T> = T extends Array<infer R> ? R : T;\n\nexport type IOperation<T> = IFilterOperation<T> | IMapOperation<T> | ITransformOperation<T>;\n\nexport class PipelineExecutor<T extends unknown[], R extends unknown[]> {\n  private readonly operations: IOperation<any>[] = [];\n  constructor(private _input?: Promise<T> | T) {}\n\n  public execute(input?: Promise<T> | T) {\n    this._input = input || this._input || ([] as T);\n\n    function isPromise(p: unknown): p is Promise<Awaited<T>> {\n      return p && Object.prototype.toString.call(p) === '[object Promise]';\n    }\n\n    if (isPromise(this._input)) {\n      return this._input.then((x) => this._execute(x));\n    } else {\n      return this._execute(this._input as Awaited<T>);\n    }\n  }\n\n  private _execute(input: T): R {\n    const acc: unknown[] = [];\n\n    for (let index = 0; index < input.length; index++) {\n      let value = input[index];\n      let isValid = true;\n\n      for (const { type, callback } of this.operations) {\n        if (type === OperationType.FILTER) {\n          if (!callback(value, index, acc)) {\n            isValid = false;\n            break;\n          }\n        } else if (type === OperationType.MAP) {\n          value = callback(value, index, acc);\n        } else if (type === OperationType.TRANSFORM) {\n          callback(value, index, acc);\n        } else {\n          throw new Error('Unknown executor operation!');\n        }\n      }\n\n      if (isValid) {\n        acc.push(value);\n      }\n    }\n\n    return acc as R;\n  }\n\n  private addOperation(operation: IOperation<any>) {\n    this.operations.push(operation);\n    return this;\n  }\n\n  public clear() {\n    this.operations.length = 0;\n    return this;\n  }\n\n  public addFilter<L = Unwrapped<T>>(callback: IFilterOperation<L>['callback']) {\n    return this.addOperation({\n      type: OperationType.FILTER,\n      callback,\n    });\n  }\n\n  public addMap<L = Unwrapped<T>>(callback: IMapOperation<L>['callback']) {\n    return this.addOperation({\n      type: OperationType.MAP,\n      callback,\n    });\n  }\n\n  public addTransform<L = Unwrapped<T>>(callback: ITransformOperation<L>['callback']) {\n    return this.addOperation({\n      type: OperationType.TRANSFORM,\n      callback,\n    });\n  }\n}\n","import { GetColumnIndexType, GroupByOptions } from './types';\n\nconst takeFirstHandler = (rows: string[][]) => rows[0];\n\nexport function groupBy(\n  rows: string[][],\n  { cols, handler = takeFirstHandler }: GroupByOptions,\n  getColumnIndex: GetColumnIndexType,\n): string[][] {\n  const rowsByKey = new Map<string, string[][]>();\n\n  rows.forEach((row) => {\n    const key = cols.map((col) => row[getColumnIndex(col)]).join('-');\n    if (!rowsByKey.has(key)) {\n      rowsByKey.set(key, []);\n    }\n    rowsByKey.get(key)!.push(row);\n  });\n\n  return Array.from(rowsByKey.values()).map((rows) => {\n    if (rows.length > 1) {\n      return handler(rows, getColumnIndex);\n    }\n    return rows[0];\n  });\n}\n","export const asObject =\n  <T extends string>(getColumnName: (i: number) => T) =>\n  (row: string[]): Record<T, string> => {\n    return row.reduce((acc, value, index) => {\n      const key = getColumnName(index);\n      acc[key] = value;\n      return acc;\n    }, {} as Record<T, string>);\n  };\n\nexport const asCsv = (separator: string) => (row: string[]) => {\n  return row.join(separator);\n};\n\nexport const asArray = () => (row: string[]) => {\n  return row;\n};\n","import { FullParserSettings, RowValidationPolicy } from './types';\nimport { extraColsMapperFactory, getColumnsInfo } from './helpers';\nimport { ElementHandle } from 'puppeteer';\nimport { InvalidSettingsError } from './errors';\nimport { PipelineExecutor } from './pipelineExecutor';\nimport { groupBy } from './aggregations';\nimport * as mappers from './mappers';\n\nexport function parseTableFactory(settings: FullParserSettings) {\n  const extraColsMapper = extraColsMapperFactory(settings.extraCols);\n\n  const getHeaderRows = (table: ElementHandle) => {\n    return settings.headerRowsSelector\n      ? table.$$(settings.headerRowsSelector)\n      : Promise.resolve([]);\n  };\n\n  const getBodyRows = (table: ElementHandle) => {\n    return table.$$(settings.bodyRowsSelector);\n  };\n\n  const getOutputHeaderRow = (missingColNames: string[]) => {\n    const headerRowRaw = Object.values(settings.allowedColNames);\n    const sortedHeader = extraColsMapper(headerRowRaw, 'colName');\n\n    return sortedHeader.filter((key) => !missingColNames.includes(key));\n  };\n\n  const getRowStructureValidator = (allowedIndexes: Record<string, number>) => {\n    if (settings.rowValidationPolicy === RowValidationPolicy.NONE) {\n      return () => true;\n    }\n    if (settings.rowValidationPolicy === RowValidationPolicy.NON_EMPTY) {\n      return (rows: string[]) => rows.length > 0;\n    }\n    if (settings.rowValidationPolicy === RowValidationPolicy.EXACT_MATCH) {\n      return (rows: string[]) => rows.length === Object.keys(allowedIndexes).length;\n    }\n    throw new InvalidSettingsError('Unknown mode for the \"rowValidationPolicy\"');\n  };\n\n  const getRowsData =\n    (allowedIndexes: Record<string, number>) =>\n    (row: ElementHandle): Promise<string[]> =>\n      row.$$eval(\n        'td',\n        (cells: HTMLElement[], allowedIndexes: Record<string, number>) => {\n          return cells\n            .map((cell, realIndex) => [cell, realIndex])\n            .filter((_, realIndex) => allowedIndexes[realIndex] !== undefined)\n            .sort((a, b) => {\n              const indexA = allowedIndexes[a[1] as number];\n              const indexB = allowedIndexes[b[1] as number];\n\n              return indexA - indexB;\n            })\n            .map(([cell]): string => (cell as HTMLElement).innerText);\n        },\n        allowedIndexes,\n      );\n\n  return async (table: ElementHandle, addHeader: boolean) => {\n    await table.evaluate((el) => el.scrollIntoView());\n\n    const headerRows: ElementHandle[] = await getHeaderRows(table);\n    const bodyRows: ElementHandle[] = await getBodyRows(table);\n\n    if (headerRows.length === 0 && bodyRows.length === 0) {\n      return [];\n    }\n\n    const headerRow: ElementHandle = headerRows.length > 0 ? headerRows.shift() : bodyRows.shift();\n\n    const { indexes, getColumnIndex, getColumnName, missingColNames } = await getColumnsInfo(\n      settings,\n      headerRow,\n      extraColsMapper,\n    );\n\n    if (settings.reverseTraversal) {\n      bodyRows.reverse();\n    }\n\n    let parsedRows = await new PipelineExecutor<string[][], string[][]>(\n      Promise.all(bodyRows.map(getRowsData(indexes.allowed))),\n    )\n      .addFilter(getRowStructureValidator(indexes.allowed))\n      .addMap((row) => extraColsMapper(row, 'data'))\n      .addFilter((row, index, rows) => settings.rowValidator(row, getColumnIndex, index, rows))\n      .addMap((row) => row.map((cell, index) => settings.colParser(cell, index, getColumnIndex)))\n      .addTransform((row) => settings.rowTransform(row, getColumnIndex))\n      .execute();\n\n    if (settings.groupBy) {\n      parsedRows = groupBy(parsedRows, settings.groupBy, getColumnIndex);\n    }\n\n    if (addHeader) {\n      const headerRow = getOutputHeaderRow(missingColNames);\n      parsedRows.unshift(headerRow);\n    }\n\n    const rowOutputMapper = settings.rowValuesAsObject\n      ? mappers.asObject(getColumnName)\n      : settings.rowValuesAsArray\n      ? mappers.asArray()\n      : mappers.asCsv(settings.csvSeparator);\n\n    return new PipelineExecutor<string[][], ReturnType<typeof rowOutputMapper>[]>(parsedRows)\n      .addMap((row) => row.filter((_, index) => !indexes.excluded.includes(index)))\n      .addMap(rowOutputMapper)\n      .execute();\n  };\n}\n","import type { MergeParserSettings } from './types';\n\nexport const mergeParserSettings = (\n  to: MergeParserSettings,\n  from: MergeParserSettings,\n  ignoredAllowedColumns: string[] = [],\n): MergeParserSettings => {\n  const newConfig: MergeParserSettings = {\n    temporaryColNames: to.temporaryColNames.slice(),\n    extraCols: to.extraCols.slice(),\n    allowedColNames: Object.assign({}, to.allowedColNames),\n  };\n\n  newConfig.extraCols.unshift(\n    ...from.extraCols.map((extraCol) => {\n      extraCol.data = extraCol.data || '';\n      return extraCol;\n    }),\n  );\n  from.temporaryColNames\n    .filter((tempCol) => !newConfig.temporaryColNames.includes(tempCol))\n    .forEach((tempCol) => newConfig.temporaryColNames.push(tempCol));\n\n  // Get columns from general table\n  const generalColNames = Object.entries(from.allowedColNames);\n\n  // Merge them together\n  generalColNames.reverse().forEach(([key, val], index) => {\n    const realPosition = generalColNames.length - index - 1;\n\n    // If column does not exist yet and is not excluded\n    if (!newConfig.allowedColNames.hasOwnProperty(key) && !ignoredAllowedColumns.includes(key)) {\n      const searchEntry = newConfig.extraCols.find((col) => col.colName === key);\n\n      // Column already exists, just update position to match\n      if (searchEntry) {\n        searchEntry.position = realPosition;\n        return;\n      }\n\n      // Insert new column\n      newConfig.extraCols.unshift({\n        colName: val,\n        data: '',\n        position: realPosition,\n      });\n    }\n  });\n\n  return newConfig;\n};\n","import {\n  FullParserSettings,\n  ParserSettings,\n  ParserSettingsOptional,\n  RowValidationPolicy,\n} from './types';\nimport { InvalidSettingsError } from './errors';\nimport { omitUndefined } from './helpers';\n\nexport const defaultSettings: ParserSettingsOptional = {\n  extraCols: [],\n  withHeader: true,\n  csvSeparator: ';',\n  newLine: '\\n',\n  rowValidationPolicy: RowValidationPolicy.NON_EMPTY,\n  groupBy: undefined,\n  rowValidator: () => true,\n  rowTransform: () => {},\n  asArray: false,\n  rowValuesAsObject: false,\n  rowValuesAsArray: false,\n  temporaryColNames: [],\n  colFilter: (elText) => elText.join(' '),\n  colParser: (value) => value.trim(),\n  optionalColNames: [],\n  reverseTraversal: false,\n  headerRowsSelector: 'thead tr',\n  bodyRowsSelector: 'tbody tr',\n};\n\nexport function preprocessSettings(options: ParserSettings): FullParserSettings {\n  const settings: FullParserSettings = {\n    ...defaultSettings,\n    ...omitUndefined(options),\n  };\n\n  if (!settings.asArray && (settings.rowValuesAsObject || settings.rowValuesAsArray)) {\n    settings.asArray = false;\n  }\n\n  validateSettings(settings);\n  return settings;\n}\n\nexport function validateSettings(\n  settings: FullParserSettings,\n): asserts settings is FullParserSettings {\n  const { extraCols, temporaryColNames, allowedColNames } = settings;\n\n  const hasConflict = extraCols\n    .filter((col) => col.position !== undefined)\n    .some((a) => extraCols.find((b) => a !== b && a.position === b.position));\n\n  if (hasConflict) {\n    throw new InvalidSettingsError('One or more `extraCols` have same position!');\n  }\n\n  for (const colName of temporaryColNames) {\n    if (!Object.prototype.hasOwnProperty.call(allowedColNames, colName)) {\n      throw new InvalidSettingsError(\n        `Entry ${colName} in 'temporaryColNames' must exists in 'allowedColNames'!`,\n      );\n    }\n  }\n\n  const allowedColNamesValues = Object.values(allowedColNames);\n  for (const { colName } of extraCols) {\n    if (allowedColNamesValues.includes(colName)) {\n      throw new InvalidSettingsError(\n        `'${colName}' in 'extraCols' has same name as column in 'allowedColNames'!`,\n      );\n    }\n  }\n\n  if (!settings.asArray && settings.rowValuesAsArray) {\n    throw new InvalidSettingsError(\n      `'rowValuesAsArray' can be set to true only and only if 'asArray' is also true!`,\n    );\n  }\n\n  if (!Array.isArray(settings.optionalColNames)) {\n    throw new InvalidSettingsError(`'optionalColNames' must be an \"array\"`);\n  }\n  for (const optionalColName of settings.optionalColNames) {\n    if (!allowedColNamesValues.includes(optionalColName)) {\n      throw new InvalidSettingsError(\n        `'${optionalColName}' in 'optionalColNames' does not exists in 'allowedColNames'!`,\n      );\n    }\n  }\n\n  if (settings.groupBy) {\n    if (!Array.isArray(settings.groupBy.cols)) {\n      throw new InvalidSettingsError(`Columns in \"groupBy\" field must be typeof array`);\n    }\n    if (settings.groupBy.handler && typeof settings.groupBy.handler !== 'function') {\n      throw new InvalidSettingsError(`Passed handler to the \"groupBy\" is not a function`);\n    }\n  }\n\n  if (settings.rowValuesAsObject && settings.rowValuesAsArray) {\n    throw new InvalidSettingsError(\n      `Cannot combine \"rowValuesAsObject\" with \"rowValuesAsArray\" options!`,\n    );\n  }\n}\n","import { ElementHandle, Page } from 'puppeteer';\nimport { ParserSettings, FullParserSettings, OmitOrFalsy } from './types';\nimport { parseTableFactory } from './parseTable';\nimport { mergeParserSettings } from './merger';\nimport { preprocessSettings } from './settings';\nimport { NoTablesFoundError } from './errors';\n\nasync function retrieveTables(page: Page, selector: string) {\n  await page.waitForSelector(selector);\n\n  const elements: ElementHandle[] = await page.$$(selector);\n  const elementsTypes: string[] = await Promise.all(\n    elements.map((elHandle) => elHandle.evaluate((el) => el.tagName)),\n  );\n\n  return elements.filter((el, index) => {\n    const elType: string = elementsTypes[index];\n    if (elType !== 'TABLE') {\n      console.warn('Invalid selector! Element is not a table!');\n      return false;\n    }\n    return true;\n  });\n}\n\nexport async function tableParser(\n  page: Page,\n  settings: Omit<ParserSettings, 'asArray'> & {\n    asArray: true;\n    rowValuesAsArray?: false;\n    rowValuesAsObject?: false;\n  },\n): Promise<string[]>;\nexport async function tableParser(\n  page: Page,\n  settings: Omit<ParserSettings, 'asArray' | 'rowValuesAsArray'> & {\n    asArray: true;\n    rowValuesAsArray: true;\n    rowValuesAsObject?: false;\n  },\n): Promise<string[][]>;\nexport async function tableParser<T extends string>(\n  page: Page,\n  settings: Omit<\n    ParserSettings,\n    'asArray' | 'rowValuesAsArray' | 'rowValuesAsObject' | 'allowedColNames'\n  > & {\n    asArray: boolean;\n    rowValuesAsObject: true;\n    rowValuesAsArray?: false;\n    allowedColNames: Record<string, T>;\n  },\n): Promise<Record<T, string>[]>;\nexport async function tableParser(\n  page: Page,\n  options: OmitOrFalsy<ParserSettings, 'asArray' | 'rowValuesAsObject' | 'rowValuesAsArray'>,\n): Promise<string>;\nexport async function tableParser<T extends ParserSettings>(page: Page, options: T) {\n  const settings: FullParserSettings = preprocessSettings(options);\n\n  const tables: ElementHandle[] = await retrieveTables(page, settings.selector);\n\n  if (tables.length === 0) {\n    throw new NoTablesFoundError('No tables found! Probably wrong table selector!');\n  }\n\n  const parseTable = parseTableFactory(settings);\n\n  const tableResults: Array<Awaited<ReturnType<typeof parseTable>>> = [];\n  let headerFound = false;\n\n  for (const table of tables) {\n    const withHeader = settings.withHeader && !settings.rowValuesAsObject && !headerFound;\n    const data = await parseTable(table, withHeader);\n\n    if (data.length > 0 && withHeader) {\n      headerFound = true;\n    }\n    tableResults.push(data);\n  }\n\n  const filteredDataTables = tableResults.flat().filter(Boolean);\n\n  if (!settings.asArray) {\n    return filteredDataTables.join(settings.newLine);\n  }\n\n  return filteredDataTables;\n}\n\nexport { mergeParserSettings };\nexport * from './types';\nexport * from './errors';\n"]}